import builtins from "builtin-modules"
import dotenv from "dotenv"
import esbuild from "esbuild"
import { watch } from "fs"
import fs from "fs/promises"
import { glob } from "glob"
import path from "path"
import process from "process"
import { fileURLToPath } from "url"

// Load environment variables
dotenv.config()

const __dirname = fileURLToPath(new URL(".", import.meta.url))
const outDir = process.env.VAULT_PLUGIN_PATH

if (!outDir) {
  console.error("Error: VAULT_PLUGIN_PATH environment variable is not set")
  console.error(
    "Please create a .env file with VAULT_PLUGIN_PATH=/path/to/vault/.obsidian/plugins/your-plugin"
  )
  process.exit(1)
}

// Bundle all CSS files into one
async function bundleCssFiles() {
  try {
    // Find all CSS files in src directory
    const cssFiles = glob
      .sync("src/**/*.css")
      .filter(file => file !== "src/styles.css")

    // Start with the main styles.css content if it exists
    let mainCssContent = ""
    try {
      mainCssContent = await fs.readFile("src/styles.css", "utf8")
      mainCssContent += "\n\n/* Auto-collected component and view styles */\n"
    } catch (error) {
      // No main styles.css, create a header
      mainCssContent = "/* Auto-collected CSS */\n\n"
    }

    // Add each component/view CSS file content
    for (const file of cssFiles) {
      const componentName = path.basename(file, ".css")
      const fileContent = await fs.readFile(file, "utf8")

      // Add a comment to identify the source
      mainCssContent += `\n/* Styles from ${file} */\n`
      mainCssContent += fileContent
      mainCssContent += "\n"
    }

    // Write the bundled CSS to the output directory
    await fs.writeFile(path.join(outDir, "styles.css"), mainCssContent)

    console.info("CSS files bundled successfully")
  } catch (error) {
    console.error("Error bundling CSS files:", error)
  }
}

// Copy additional plugin files
async function copyPluginFiles() {
  try {
    // Create the directory if it doesn't exist
    await fs.mkdir(outDir, { recursive: true })

    // Copy manifest.json
    await fs.copyFile("src/manifest.json", path.join(outDir, "manifest.json"))

    // Bundle CSS files
    await bundleCssFiles()

    console.info("Plugin files copied successfully")
  } catch (error) {
    console.error("Error copying plugin files:", error)
  }
}

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`

const prod = process.argv[2] === "production"

const context = await esbuild.context({
  banner: {
    js: banner,
  },
  entryPoints: ["src/main.ts"],
  bundle: true,
  external: [
    "obsidian",
    "electron",
    "@codemirror/autocomplete",
    "@codemirror/collab",
    "@codemirror/commands",
    "@codemirror/language",
    "@codemirror/lint",
    "@codemirror/search",
    "@codemirror/state",
    "@codemirror/view",
    "@lezer/common",
    "@lezer/highlight",
    "@lezer/lr",
    ...builtins,
  ],
  format: "cjs",
  target: "es2018",
  logLevel: "info",
  sourcemap: prod ? false : "inline",
  treeShaking: true,
  outfile: path.join(outDir, "main.js"),
  minify: prod,
  alias: {
    "@": path.resolve(__dirname, "src"),
  },
})

if (prod) {
  await context.rebuild()
  await copyPluginFiles()
  process.exit(0)
} else {
  // Initial copy of plugin files
  await copyPluginFiles()

  // Set up file watcher for the entire src directory
  const watcher = watch(
    "src",
    { recursive: true },
    async (eventType, filename) => {
      if (filename === "manifest.json") {
        await copyPluginFiles()
      } else if (filename && filename.endsWith(".css")) {
        // Re-bundle CSS whenever any CSS file changes
        await bundleCssFiles()
      }
    }
  )

  // Handle cleanup on process termination
  process.on("SIGINT", () => {
    watcher.close()
    context.dispose()
    process.exit(0)
  })

  // Start the watch mode
  await context.watch()
}
